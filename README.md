# Object Oriented Programming And Design
 CS-635
 
Assignment 1:
1. Implement a circular doubly linked queue. Your queue needs to support adding new elements, return the element with the first element and removing the first element. Adding an element and removing the element with the highest element should be at most O(1) where N is the size of the queue. The queue should start with a capacity greater that 1. When the queue is full and another element is added the queue capacity should be doubled. If additions and deletions are intermixed it is possible that a large number additions can be done without increasing the capacity.
2. Your queue needs to be able to hold process objects. A process has a name (String), an owner (String), PID (int), number of threads, percent of CPU currently being used and total amount of CPU time used. 
3. Programs that use your queue will want to display and print out the elements in the queue. They will need to display/print out the queue ordered by name, PID, CPU time used, percent of CPU time, total CPU time or by owner.

Assignment 2:
1. Use the Interpreter pattern to evaluate postﬁx expressions. The expression (1967 + 21) * sin(3) will be 1967 21 + 3 sin * in postﬁx. For more information about postﬁx see the Wikipedia entry entry. You should support at least the operations +, -, *, / , lg (base 2) and sin. You may restrict the input to integer values. However the result may be a ﬂoating point number since we are including lg and sin. Postﬁx is used here to simplify the parsing. If you prefer to use normal arithmetic expressions you may.
2.  Implement a spreadsheet with 9 cells  with a GUI. The cells are labeled $A, $B, $C, $D, $E, $F, $G, $H, $I. (If you prefer you can use a 2-dimensional layout with the cells labeled $A$A, $A$B, $A$C, $B$A, $B$B, etc) A cell can contain either a formula, a number or be empty. A formula can contain numbers, reference to cells and the operations. In the ﬁrst example below cell $A contains 1, $B contains the number 2, $C contains the formula $A $B +, and $E contains the formula $A $C +. We have an equation and a value view of the cells. The two tables below shows both the equation and the value views of the cells. Provide the user with a button to switch between views. That is you display the spreadsheet once and the user can toggle the view between the two views by clicking on a button. You need provide a way for the user to enter values and equations. You either allow the user to enter the values directly in a cell or provide them with a separate input ﬁeld to enter values and/or equations. While in the value view if a user changes the value of a cell (for example cell $B) then all cells dependent on that cell need to be updated automatically. Note that more than one cell may require updating. One may be tempted to update all the cells whenever a user modiﬁes one cell. However this will not scale to a really spreadsheet, so do not do it. When a user modiﬁes one cell only update the cells that are effected by the change.
3. Add an undo mechanism to your spreadsheet. The undo mechanism should be unlimited. However the undo history does not have to span multiple invocations of the program. That is when you start the program your undo history can start empty. Each change the user makes in either a value or an equations is to be undoable.

Assignment 3:
1. Implements a binary search tree with addition. You don’t have to implement delete on the tree. The nodes in the tree contain strings.
2. Use the Null Object pattern to add a null node to your tree to eliminate the need to check for null references or pointers in your tree.
3. Modify your Binary Search Tree that uses Null object to accept a Visitor. Implement a Visitor to produce the following representation of a search tree. Each node maps to (Value (Left Subtree)(Right Subtree)). So the representation of the tree below is (5 (3 () (4 () ()))(10 () ())).
4. Use the Strategy pattern so that clients can provide an ordering that the tree will use to order its elements. Implement two orderings. The first ordering is the normal lexicographic (or alphabetic) ordering for strings. The second ordering compares strings by first reversing the string and then comparing the strings lexicographically. In the second ordering "az" would come after "bb".

Assignment 4:<br/><br/>
In this assignment we will investigate the ﬂyweight pattern. We will look at a ﬂyweight for characters. We will look at a ﬂyweight for characters. The example in the text shows an example of an object-oriented word processor that uses objects to represent characters. One reason they represent characters as objects is that they use the Composite pattern to represent the contents of a document. Some of the contents, images for example, must be objects. So in a language like Java all the elements of the document need to be objects. In a document we have letters from an alphabet and font information. In theory each character could have different font (font name, point size and style). In practice the font does not change very often.  So we will use the Flyweight to save space. You will create a Character class that will store only the unicode code point of the character. You need a Flyweight factory that given a unicode code point (a char in Java) returns the Flyweight character object for the character. You need to have a single point of access to the same Flyweight factory from anywhere in your program. Since documents tend to use the same fonts repeatedly we will also use a Flyweight factory for fonts.  In this factory the input will be a triple: the font name (Times, Courier, etc), point size (12, 13, etc) and style (bold, italic, underline, etc). This factory also needs a single point of access. 
For the Character Flyweight to work we need to a way to story the extrinsic state of the character objects, that is the font information. For this we will use a RunArray. A RunArray keeps track of runs in a sequence. For example if we have a document that starts with 250 characters in font A, then has 10 characters in font B and ﬁnally 320 characters in font A. The RunArray needs to store the runs: 250, 10 and 320. It also has to store the font that is associated with each run. Given any index (0 to 579 or 1 to 580) the run array will return the font used by the character in that location of the document. So give index 12 the RunArray will return Font A, given the index 255 will return Font B. When adding runs to the RunArray one needs to indicate the index the run starts at, the length of the run and the value at the run array.
The goal of the Flyweight is to save space. So the question is how much space does this save for sample documents. To answer this question on have to be able to compute the space of objects. For example on a 64bit machine an empty object in Java takes up 16 bytes, a font object takes up 72 bytes. A tool to measure the size of Java objects can be found at: http://java.dzone.com/articles/java-getting-size-object. Later I will give you some data from sample documents. You will use the data to compute how much space using ﬂyweights saves.
